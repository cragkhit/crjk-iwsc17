package org.apache.tomcat.dbcp.dbcp2;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.NoSuchElementException;
import org.apache.tomcat.dbcp.pool2.KeyedObjectPool;
import org.apache.tomcat.dbcp.pool2.KeyedPooledObjectFactory;
import org.apache.tomcat.dbcp.pool2.PooledObject;
import org.apache.tomcat.dbcp.pool2.impl.DefaultPooledObject;
public class PoolingConnection extends DelegatingConnection<Connection>
    implements KeyedPooledObjectFactory<PStmtKey, DelegatingPreparedStatement> {
    private KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> _pstmtPool = null;
    public PoolingConnection ( final Connection c ) {
        super ( c );
    }
    public void setStatementPool (
        final KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> pool ) {
        _pstmtPool = pool;
    }
    @Override
    public synchronized void close() throws SQLException {
        try {
            if ( null != _pstmtPool ) {
                final KeyedObjectPool<PStmtKey, DelegatingPreparedStatement> oldpool = _pstmtPool;
                _pstmtPool = null;
                try {
                    oldpool.close();
                } catch ( final RuntimeException e ) {
                    throw e;
                } catch ( final Exception e ) {
                    throw new SQLException ( "Cannot close connection", e );
                }
            }
        } finally {
            try {
                getDelegateInternal().close();
            } finally {
                setClosedInternal ( true );
            }
        }
    }
    @Override
    public PreparedStatement prepareStatement ( final String sql ) throws SQLException {
        if ( null == _pstmtPool ) {
            throw new SQLException (
                "Statement pool is null - closed or invalid PoolingConnection." );
        }
        try {
            return _pstmtPool.borrowObject ( createKey ( sql ) );
        } catch ( final NoSuchElementException e ) {
            throw new SQLException ( "MaxOpenPreparedStatements limit reached", e );
        } catch ( final RuntimeException e ) {
            throw e;
        } catch ( final Exception e ) {
            throw new SQLException ( "Borrow prepareStatement from pool failed", e );
        }
    }
    @Override
    public PreparedStatement prepareStatement ( final String sql, final int autoGeneratedKeys ) throws SQLException {
        if ( null == _pstmtPool ) {
            throw new SQLException (
                "Statement pool is null - closed or invalid PoolingConnection." );
        }
        try {
            return _pstmtPool.borrowObject ( createKey ( sql, autoGeneratedKeys ) );
        } catch ( final NoSuchElementException e ) {
            throw new SQLException ( "MaxOpenPreparedStatements limit reached", e );
        } catch ( final RuntimeException e ) {
            throw e;
        } catch ( final Exception e ) {
            throw new SQLException ( "Borrow prepareStatement from pool failed", e );
        }
    }
    @Override
    public PreparedStatement prepareStatement ( final String sql, final int resultSetType, final int resultSetConcurrency ) throws SQLException {
        if ( null == _pstmtPool ) {
            throw new SQLException (
                "Statement pool is null - closed or invalid PoolingConnection." );
        }
        try {
            return _pstmtPool.borrowObject ( createKey ( sql, resultSetType, resultSetConcurrency ) );
        } catch ( final NoSuchElementException e ) {
            throw new SQLException ( "MaxOpenPreparedStatements limit reached", e );
        } catch ( final RuntimeException e ) {
            throw e;
        } catch ( final Exception e ) {
            throw new SQLException ( "Borrow prepareStatement from pool failed", e );
        }
    }
    @Override
    public CallableStatement prepareCall ( final String sql ) throws SQLException {
        try {
            return ( CallableStatement ) _pstmtPool.borrowObject ( createKey ( sql, StatementType.CALLABLE_STATEMENT ) );
        } catch ( final NoSuchElementException e ) {
            throw new SQLException ( "MaxOpenCallableStatements limit reached", e );
        } catch ( final RuntimeException e ) {
            throw e;
        } catch ( final Exception e ) {
            throw new SQLException ( "Borrow callableStatement from pool failed", e );
        }
    }
    @Override
    public CallableStatement prepareCall ( final String sql, final int resultSetType, final int resultSetConcurrency ) throws SQLException {
        try {
            return ( CallableStatement ) _pstmtPool.borrowObject ( createKey ( sql, resultSetType,
                    resultSetConcurrency, StatementType.CALLABLE_STATEMENT ) );
        } catch ( final NoSuchElementException e ) {
            throw new SQLException ( "MaxOpenCallableStatements limit reached", e );
        } catch ( final RuntimeException e ) {
            throw e;
        } catch ( final Exception e ) {
            throw new SQLException ( "Borrow callableStatement from pool failed", e );
        }
    }
    protected PStmtKey createKey ( final String sql, final int autoGeneratedKeys ) {
        String catalog = null;
        try {
            catalog = getCatalog();
        } catch ( final SQLException e ) {
        }
        return new PStmtKey ( normalizeSQL ( sql ), catalog, autoGeneratedKeys );
    }
    protected PStmtKey createKey ( final String sql, final int resultSetType, final int resultSetConcurrency ) {
        String catalog = null;
        try {
            catalog = getCatalog();
        } catch ( final SQLException e ) {
        }
        return new PStmtKey ( normalizeSQL ( sql ), catalog, resultSetType, resultSetConcurrency );
    }
    protected PStmtKey createKey ( final String sql, final int resultSetType, final int resultSetConcurrency, final StatementType stmtType ) {
        String catalog = null;
        try {
            catalog = getCatalog();
        } catch ( final SQLException e ) {
        }
        return new PStmtKey ( normalizeSQL ( sql ), catalog, resultSetType, resultSetConcurrency, stmtType );
    }
    protected PStmtKey createKey ( final String sql ) {
        String catalog = null;
        try {
            catalog = getCatalog();
        } catch ( final SQLException e ) {
        }
        return new PStmtKey ( normalizeSQL ( sql ), catalog );
    }
    protected PStmtKey createKey ( final String sql, final StatementType stmtType ) {
        String catalog = null;
        try {
            catalog = getCatalog();
        } catch ( final SQLException e ) {
        }
        return new PStmtKey ( normalizeSQL ( sql ), catalog, stmtType, null );
    }
    protected String normalizeSQL ( final String sql ) {
        return sql.trim();
    }
    @Override
    public PooledObject<DelegatingPreparedStatement> makeObject ( final PStmtKey key )
    throws Exception {
        if ( null == key ) {
            throw new IllegalArgumentException ( "Prepared statement key is null or invalid." );
        }
        if ( null == key.getResultSetType() && null == key.getResultSetConcurrency() && null == key.getAutoGeneratedKeys() ) {
            if ( key.getStmtType() == StatementType.PREPARED_STATEMENT ) {
                @SuppressWarnings ( {"rawtypes", "unchecked"} )
                final
                PoolablePreparedStatement pps = new PoolablePreparedStatement (
                    getDelegate().prepareStatement ( key.getSql() ), key, _pstmtPool, this );
                return new DefaultPooledObject<> ( pps );
            }
            return new DefaultPooledObject<> (
                       new PoolableCallableStatement ( getDelegate().prepareCall ( key.getSql() ), key, _pstmtPool, this ) );
        } else if ( null == key.getResultSetType() && null == key.getResultSetConcurrency() ) {
            @SuppressWarnings ( {"rawtypes", "unchecked"} )
            final
            PoolablePreparedStatement pps = new PoolablePreparedStatement (
                getDelegate().prepareStatement ( key.getSql(), key.getAutoGeneratedKeys().intValue() ), key, _pstmtPool, this );
            return new DefaultPooledObject<> ( pps );
        } else {
            if ( key.getStmtType() == StatementType.PREPARED_STATEMENT ) {
                @SuppressWarnings ( {"rawtypes", "unchecked"} )
                final
                PoolablePreparedStatement pps = new PoolablePreparedStatement ( getDelegate().prepareStatement (
                            key.getSql(), key.getResultSetType().intValue(), key.getResultSetConcurrency().intValue() ), key, _pstmtPool, this );
                return new DefaultPooledObject<> ( pps );
            }
            return new DefaultPooledObject<> (
                       new PoolableCallableStatement ( getDelegate().prepareCall (
                                   key.getSql(), key.getResultSetType().intValue(), key.getResultSetConcurrency().intValue() ), key, _pstmtPool, this ) );
        }
    }
    @Override
    public void destroyObject ( final PStmtKey key,
                                final PooledObject<DelegatingPreparedStatement> p )
    throws Exception {
        p.getObject().getInnermostDelegate().close();
    }
    @Override
    public boolean validateObject ( final PStmtKey key,
                                    final PooledObject<DelegatingPreparedStatement> p ) {
        return true;
    }
    @Override
    public void activateObject ( final PStmtKey key,
                                 final PooledObject<DelegatingPreparedStatement> p ) throws Exception {
        p.getObject().activate();
    }
    @Override
    public void passivateObject ( final PStmtKey key,
                                  final PooledObject<DelegatingPreparedStatement> p ) throws Exception {
        final DelegatingPreparedStatement dps = p.getObject();
        dps.clearParameters();
        dps.passivate();
    }
    @Override
    public String toString() {
        if ( _pstmtPool != null ) {
            return "PoolingConnection: " + _pstmtPool.toString();
        }
        return "PoolingConnection: null";
    }
    protected static enum StatementType {
        CALLABLE_STATEMENT,
        PREPARED_STATEMENT
    }
}
