package org.apache.tomcat.dbcp.dbcp2.cpdsadapter;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import org.apache.tomcat.dbcp.dbcp2.DelegatingConnection;
import org.apache.tomcat.dbcp.dbcp2.DelegatingPreparedStatement;
class ConnectionImpl extends DelegatingConnection<Connection> {
    private final boolean accessToUnderlyingConnectionAllowed;
    private final PooledConnectionImpl pooledConnection;
    ConnectionImpl ( final PooledConnectionImpl pooledConnection,
                     final Connection connection,
                     final boolean accessToUnderlyingConnectionAllowed ) {
        super ( connection );
        this.pooledConnection = pooledConnection;
        this.accessToUnderlyingConnectionAllowed =
            accessToUnderlyingConnectionAllowed;
    }
    @Override
    public void close() throws SQLException {
        if ( !isClosedInternal() ) {
            try {
                passivate();
            } finally {
                setClosedInternal ( true );
                pooledConnection.notifyListeners();
            }
        }
    }
    @Override
    public PreparedStatement prepareStatement ( final String sql ) throws SQLException {
        checkOpen();
        try {
            return new DelegatingPreparedStatement
                   ( this, pooledConnection.prepareStatement ( sql ) );
        } catch ( final SQLException e ) {
            handleException ( e );
            return null;
        }
    }
    @Override
    public PreparedStatement prepareStatement ( final String sql, final int resultSetType,
            final int resultSetConcurrency )
    throws SQLException {
        checkOpen();
        try {
            return new DelegatingPreparedStatement
                   ( this, pooledConnection.prepareStatement
                     ( sql, resultSetType, resultSetConcurrency ) );
        } catch ( final SQLException e ) {
            handleException ( e );
            return null;
        }
    }
    @Override
    public PreparedStatement prepareStatement ( final String sql, final int resultSetType,
            final int resultSetConcurrency,
            final int resultSetHoldability )
    throws SQLException {
        checkOpen();
        try {
            return new DelegatingPreparedStatement ( this,
                    pooledConnection.prepareStatement ( sql, resultSetType,
                            resultSetConcurrency, resultSetHoldability ) );
        } catch ( final SQLException e ) {
            handleException ( e );
            return null;
        }
    }
    @Override
    public PreparedStatement prepareStatement ( final String sql, final int autoGeneratedKeys )
    throws SQLException {
        checkOpen();
        try {
            return new DelegatingPreparedStatement ( this,
                    pooledConnection.prepareStatement ( sql, autoGeneratedKeys ) );
        } catch ( final SQLException e ) {
            handleException ( e );
            return null;
        }
    }
    @Override
    public PreparedStatement prepareStatement ( final String sql, final int columnIndexes[] )
    throws SQLException {
        checkOpen();
        try {
            return new DelegatingPreparedStatement ( this,
                    pooledConnection.prepareStatement ( sql, columnIndexes ) );
        } catch ( final SQLException e ) {
            handleException ( e );
            return null;
        }
    }
    @Override
    public PreparedStatement prepareStatement ( final String sql, final String columnNames[] )
    throws SQLException {
        checkOpen();
        try {
            return new DelegatingPreparedStatement ( this,
                    pooledConnection.prepareStatement ( sql, columnNames ) );
        } catch ( final SQLException e ) {
            handleException ( e );
            return null;
        }
    }
    public boolean isAccessToUnderlyingConnectionAllowed() {
        return accessToUnderlyingConnectionAllowed;
    }
    @Override
    public Connection getDelegate() {
        if ( isAccessToUnderlyingConnectionAllowed() ) {
            return getDelegateInternal();
        }
        return null;
    }
    @Override
    public Connection getInnermostDelegate() {
        if ( isAccessToUnderlyingConnectionAllowed() ) {
            return super.getInnermostDelegateInternal();
        }
        return null;
    }
}
