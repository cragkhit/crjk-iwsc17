{
  "name": "IWSC 2017: Using Compilation & Decompilation to Enhance Clone Detection",
  "tagline": "A website accompanying the IWSC 2017 paper \"Using compilation/decompilation to enhance clone detection\".",
  "body": "## Project overview\r\n\r\n![Experimental framework](exp_framework.png)\r\n\r\n  We study effects of compilation and decompilation to code clone\r\n  detection in Java. Compilation/decompilation canonicalise syntactic\r\n  changes made to source code and can be used as source code\r\n  normalisation. We used NiCad to detect clones before and after\r\n  decompilation in three open source software systems, JUnit,\r\n  JFreeChart, and Tomcat. We filtered and compared the clones in the original\r\n  and decompiled clone set and found that 1,201 clone pairs (78.7\\%)\r\n  are common between the two sets while 326 pairs (21.3\\%) are only in\r\n  one of the sets. A manual investigation identified 325 out of the\r\n  326 pairs as true clones. The 252 original-only clone pairs contain\r\n  a single false positive while the 74 decompiled-only clone pairs are\r\n  all true positives. Many clones in the original source code that are\r\n  detected only after decompilation are type-3 clones that are\r\n  difficult to detect due to added or deleted statements, keywords,\r\n  package names; flipped if-else statements; or changed loops. We\r\n  suggest to use decompilation as normalisation to compliment clone\r\n  detection. By combining clones found before and after decompilation,\r\n  one can achieve higher recall without losing precision.\r\n\r\n## Downloads\r\n### Clone Oracle\r\nThe 326 clone pairs manually validated can be downloaded [here](downloads/clone_oracle.csv).\r\n\r\n### Clone Mapper\r\nThe source code of clone mapper tool can be downloaded [here](downloads/clone_mapper_src.zip).\r\n\r\n### Systems\r\nThe three selected systems for our study (junit4, jfreechart, tomcat) can be downloaded below:\r\n* JUnit4: [original](downloads/systems/junit4.zip) | [decompiled](downloads/decompile/junit4.zip)\r\n* JFreeChart: [original](downloads/systems/jfreechart.zip) | [decompiled](downloads/decompile/jfreechart.zip)\r\n* Tomcat: [original](downloads/systems/tomcat.zip) | [decompiled](downloads/decompile/tomcat.zip)\r\n\r\n## Replicate the Study\r\n1. Clone the repo: `git clone https://github.com/cragkhit/crjk-iwsc17.git`\r\n2. Download [NiCad 4.0](https://www.txl.ca/nicaddownload.html) and install it on your machine.\r\n3. Modify three NiCad's configuration files: type1.cfg, type2c.cfg, and type3-2c.cfg by changing cluster to \"yes\" (cluster=yes).\r\n4. Run NiCad against each system both the original (in iwsc2017/systems) and the decompiled version (in iwsc2017/decompile).\r\n5. Copy clone class report to a corresponding folder of each system + clone type + orig/decomp in iwsc2017/results folder. For example, for jfreechart's type 1 clones, copy jfreechart_functions-clones-0.00-classes.xml to iwsc2017/results/jfreechart/type1/orig-jfreechart_functions-clones.\r\n6. The complete result of each system will look similar to this: ![Structure of the clone reports before analysis](structure.png)\r\n7. Change directory to CloneMapper.\r\n8. Modify the config.properties by changing the location of HOME_DIR and SRC_HOME_DIR to the full path of your iwsc2017 folder and update SYSTEM with the system you want to analyse.\r\n9. Compile and run the clone mapper: `mvn compile` and `mvn exec:java`\r\n10. The common, orig-only, and decomp-only clone pairs are now created in the results folder of each system.\r\n\r\n## Contact\r\nPlease contact Chaiyong Ragkhitwetsagul (ucabagk at ucl dot ac dot uk) for any inquiries regarding this project.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}